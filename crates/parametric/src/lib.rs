use std::process::ExitStatus;

use domain::ActuatorPlate;
use validation;

pub trait Validation {
    // TODO: figure out how to mesh `plate` arg here with generic trait
    // TODO: We may want a T that matches ValidationError when we define this trait for real
    fn is_valid(plate: ActuatorPlate) -> Result<(), ValidationError>;
}

#[derive(Debug, PartialEq)]
pub enum ValidationError {
    NoStep,
}

#[derive(Debug, PartialEq)]
pub enum GeneratorError {
    CliError,
}

#[derive(Debug, PartialEq)]
pub enum AllErrors {
    GeneratorError,
    ValidationError,
}

fn generate_params_file(plate: &ActuatorPlate) -> std::io::Result<()> {
    let content = format!(
        "@settings(defaultLengthUnit = mm, kclVersion = 1.0)\n\n\
         export plateThickness = {}\n\
         export boltDiameter = {}\n\
         export boltSpacing = {}\n\
         export bracketHeight = {}\n\
         export bracketWidth = {}\n\
         export pinDiameter = {}\n\
         export pinCount = {}",
        plate.plate_thickness.0,
        plate.bolt_diameter.0,
        plate.bolt_spacing.0,
        plate.bracket_height.0,
        plate.bracket_width.0,
        plate.pin_diameter.0,
        plate.pin_count
    );

    // Write params.kcl to the same directory as main.kcl
    // Try crates/parametric/src/params.kcl first (when running from project root),
    // then fall back to src/params.kcl (when running from crates/parametric)
    let params_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
        "crates/parametric/src/params.kcl"
    } else {
        "src/params.kcl"
    };

    std::fs::write(params_path, content)?;

    Ok(())
}

pub fn generate_model(plate: &ActuatorPlate) -> Result<(), AllErrors> {
    if let Err(e) = validation::validate(&plate) {
        eprintln!("oops: {}", e);
        return Err(AllErrors::ValidationError);
    }

    // Create output directory if it doesn't exist
    if let Err(e) = std::fs::create_dir_all("output_dir") {
        eprintln!("Failed to create output directory: {}", e);
        return Err(AllErrors::GeneratorError);
    }

    if let Err(e) = generate_params_file(&plate) {
        eprintln!("oops on that param: {}", e);
        return Err(AllErrors::GeneratorError);
    }

    // Generate STEP file
    if let Err(e) = generate_step(plate.clone()) {
        eprintln!("oops generating STEP: {:?}", e);
        return Err(AllErrors::GeneratorError);
    }

    // Generate glTF file
    if let Err(e) = generate_gltf(plate.clone()) {
        eprintln!("oops generating glTF: {:?}", e);
        return Err(AllErrors::GeneratorError);
    }

    Ok(())
}

fn generate_step(plate: ActuatorPlate) -> Result<ExitStatus, ValidationError> {
    if let Err(e) = validation::validate(&plate) {
        eprintln!("oops: {}", e);
        return Err(ValidationError::NoStep);
    }

    // Try crates/parametric/src/main.kcl first (when running from project root),
    // then fall back to src/main.kcl (when running from crates/parametric)
    let kcl_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
        "crates/parametric/src/main.kcl"
    } else {
        "src/main.kcl"
    };

    let status = std::process::Command::new("zoo")
        .args(&[
            "kcl",
            "export",
            "--output-format=step",
            kcl_path,
            "output_dir",
        ])
        .status();

    match status {
        Ok(stat) => Ok(stat),
        Err(e) => {
            eprintln!("ouch: {}", e);
            return Err(ValidationError::NoStep);
        }
    }
}

fn generate_gltf(plate: ActuatorPlate) -> Result<ExitStatus, ValidationError> {
    if let Err(e) = validation::validate(&plate) {
        eprintln!("oops: {}", e);
        return Err(ValidationError::NoStep);
    }

    // The STEP file should have been generated by generate_step()
    let step_file = "output_dir/output.step";
    let output_dir = "output_dir";

    // Check if STEP file exists
    if !std::path::Path::new(step_file).exists() {
        eprintln!("STEP file does not exist at {}", step_file);
        return Err(ValidationError::NoStep);
    }

    // Convert STEP file to glTF using zoo file convert
    let status = std::process::Command::new("zoo")
        .args(&[
            "file",
            "convert",
            "--src-format=step",
            "--output-format=gltf",
            step_file,
            output_dir,
        ])
        .status();

    match status {
        Ok(stat) => Ok(stat),
        Err(e) => {
            eprintln!("ouch: {}", e);
            return Err(ValidationError::NoStep);
        }
    }
}

#[cfg(test)]
mod tests {
    use domain::Millimeters;

    use super::*;

    #[test]
    fn test_generate_step_fails_with_invalid_plate() {
        let mut plate = ActuatorPlate::default();
        plate.bolt_diameter = Millimeters(0);

        let result = generate_step(plate);

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), ValidationError::NoStep);
    }

    #[test]
    #[ignore]
    fn test_generate_model_succeeds_with_valid_plate() {
        let plate = ActuatorPlate::default();

        // This test requires zoo CLI to be installed and authenticated
        // It will generate params.kcl, STEP, and glTF files
        let result = generate_model(&plate);

        // Should succeed in generating all files
        assert!(result.is_ok());

        // Cleanup
        let params_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
            "crates/parametric/src/params.kcl"
        } else {
            "src/params.kcl"
        };
        std::fs::remove_file(params_path).ok();
        std::fs::remove_file("output_dir/output.step").ok();
        std::fs::remove_file("output_dir/output.gltf").ok();
    }

    #[test]
    fn test_generate_model_fails_with_invalid_plate() {
        let mut plate = ActuatorPlate::default();
        plate.bolt_spacing = Millimeters(0);

        let result = generate_model(&plate);

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), AllErrors::ValidationError);
    }

    #[test]
    fn test_generate_params_file_creates_valid_kcl() {
        let plate = ActuatorPlate::default();

        let result = generate_params_file(&plate);
        assert!(result.is_ok());

        // Determine the correct params.kcl path (same logic as generate_params_file)
        let params_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
            "crates/parametric/src/params.kcl"
        } else {
            "src/params.kcl"
        };

        // Read and verify the file content
        let content = std::fs::read_to_string(params_path).unwrap();

        // Check for correct format
        assert!(content.starts_with("@settings(defaultLengthUnit = mm, kclVersion = 1.0)"));
        assert!(content.contains("export plateThickness"));
        assert!(content.contains("export boltDiameter"));
        assert!(content.contains("export boltSpacing"));
        assert!(content.contains("export bracketHeight"));
        assert!(content.contains("export bracketWidth"));
        assert!(content.contains("export pinDiameter"));
        assert!(content.contains("export pinCount = 6"));

        // Cleanup
        std::fs::remove_file(params_path).ok();
    }

    #[test]
    fn test_generate_gltf_fails_with_invalid_plate() {
        let mut plate = ActuatorPlate::default();
        plate.bolt_diameter = Millimeters(0);

        let result = generate_gltf(plate);

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), ValidationError::NoStep);
    }

    // This test requires the `zoo` CLI to be installed and for the user to be authenticated; it is ignored by default
    #[test]
    #[ignore]
    fn test_generate_step_creates_file_with_zoo_cli() {
        let plate = ActuatorPlate::default();

        // This will only pass if, as pre-requisites:
        // 1. zoo CLI is installed
        // 2. user is authenticated against zoo
        // 3. main.kcl exists
        // 4. output_dir exists
        let result = generate_step(plate);

        match result {
            Ok(status) => {
                // Check if command succeeded
                assert!(status.success(), "zoo command should succeed");
            }
            Err(e) => {
                // If zoo is not installed, the test should be skipped
                panic!("Failed to run zoo command: {:?}. Is zoo CLI installed? Is the user authenticated?", e);
            }
        }

        // Cleanup
        let params_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
            "crates/parametric/src/params.kcl"
        } else {
            "src/params.kcl"
        };
        std::fs::remove_file(params_path).ok();
        std::fs::remove_file("output_dir/output.step").ok();
    }

    // This test requires the `zoo` CLI to be installed and for the user to be authenticated; it is ignored by default
    #[test]
    #[ignore]
    fn test_generate_gltf_creates_file_with_zoo_cli() {
        let plate = ActuatorPlate::default();

        // This will only pass if, as pre-requisites:
        // 1. zoo CLI is installed
        // 2. user is authenticated against zoo
        // 3. main.kcl exists
        // 4. output_dir exists

        // Generate STEP file first (glTF generation now converts from STEP)
        let step_result = generate_step(plate.clone());
        assert!(step_result.is_ok(), "STEP generation should succeed");

        let result = generate_gltf(plate);

        match result {
            Ok(status) => {
                // Check if command succeeded
                assert!(status.success(), "zoo command should succeed");
            }
            Err(e) => {
                // If zoo is not installed, the test should be skipped
                panic!("Failed to run zoo command: {:?}. Is zoo CLI installed? Is the user authenticated?", e);
            }
        }

        // Cleanup
        let params_path = if std::path::Path::new("crates/parametric/src/main.kcl").exists() {
            "crates/parametric/src/params.kcl"
        } else {
            "src/params.kcl"
        };
        std::fs::remove_file(params_path).ok();
        std::fs::remove_file("output_dir/output.step").ok();
        std::fs::remove_file("output_dir/output.gltf").ok();
    }
}
